/*
 * Copyright (c) 2020. Author:brooks   email:myt2000@126.com
 */

package com.atguiya.java3;

/**
 * super关键字的使用
 * 1.super理解为父类的：
 * 2.super可以用来调用、属性、方法、构造器
 *
 * 3.super的使用
 *  1.我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显示调用父类中声明的属性或方法。
 *  但是，通常情况下，我们习惯省略"super."
 *  2.特殊情况，当子类和父类定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则显式调用
 *  3.特殊情况，当子类重写父类中的方法以后，我们想在子类的方法中调用附列中被重写的方法时，则必须显式的使用"super.方法"的方式
 *  表明调用的是父类中被重写的方法。
 *
 * 4.super调用构造器
 *  1.我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
 *  2."super(形参列表)"的使用，必须声明在子类构造器的首行
 *  3.我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
 *  4.在构造器的首行，没有显示的声明"this(形参列表)"或"super(形参列表)"，则默认调用的父类中的空参的构造器
 *  5.在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”
 */


/**
 * 子类对象实例化的全过程
 * 1.从结果上来看：（继承性）
 *  子类继承附列以后，就获取了父类中声明的属性或方法
 *  创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
 *
 * 2.从过程上来看：
 *   当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，
 *   直到调用了java.lang.Object类中空参的构造器为止。正因为家在过所有的父类结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑使用
 *
 * 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象
 */

public class PersonTest {
    public static void main(String[] args){
        Student s = new Student();
        s.show();
    }
}


